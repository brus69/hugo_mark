---
title: "Как оптимизировать свой маркетинговый бюджет | На пути к науке о данных"
date: "2025-11-19T23:13:09+0000"
draft: false
description: ""
h1: "Как оптимизировать свой маркетинговый бюджет"
urldel: "https://towardsdatascience.com/how-to-optimize-your-marketing-budget-63707c18ba36/"
---

### Модели комплекса маркетинга — мощный инструмент для понимания влияния различных маркетинговых каналов на продажи

Модели комплекса маркетинга — это мощный инструмент для понимания влияния различных маркетинговых каналов на продажи. Создавая модель комплекса маркетинга, маркетологи могут количественно оценить вклад каждого канала в общие продажи, а затем использовать эту информацию для оптимизации распределения бюджета.

До сих пор я написал целую серию статей о **создании** моделей комплекса маркетинга, но всё ещё должен написать статью о том, как использовать эти модели для оптимизации расходов на медиа. Сегодня ваш счастливый день, поскольку в этой статье я покажу вам, как это сделать!

#### Предварительные условия

Прежде чем мы сможем что-то оптимизировать, мы должны сначала построить модель. Мы сделаем это очень быстро, чтобы как можно скорее перейти к основному разделу этой статьи.

#### Данные

Сначала давайте загрузим некоторые данные. Я буду использовать тот же набор данных, что и в моих старых статьях.

```python
import pandas as pd
from sklearn.model_selection import cross_val_score, TimeSeriesSplit

data = pd.read_csv(
    'https://raw.githubusercontent.com/Garve/datasets/4576d323bf2b66c906d5130d686245ad205505cf/mmm.csv',
    parse_dates=['Date'],
    index_col='Date'
)

X = data.drop(columns=['Sales'])
y = data['Sales']
```

Набор данных выглядит следующим образом:

Представьте, что вы работаете в компании, которая продаёт какой-то продукт. Вы можете увидеть еженедельные продажи этого продукта в столбце **Sales**. Чтобы увеличить эти продажи, вы тратите деньги на рекламу, например, на **телевидение**, **радио** и **баннерную** рекламу.

#### Модель

Построение сложных моделей, таких как XGBoost или глубокие нейронные сети, трудно интерпретировать и оптимизировать. Мы обращаемся к проверенному методу, который использует интерпретируемые эффекты переноса и насыщения для построения обобщённой аддитивной модели.

Логика, лежащая в основе этой таблицы, заключается в следующем: представьте, что вы работаете в компании, которая продаёт какой-то продукт. Вы можете увидеть еженедельные продажи этого продукта в столбце **Sales**. Чтобы увеличить эти продажи, вы тратите деньги на рекламу, например, на **телевидение**, **радио** и **баннерную** рекламу.

Мы хотим смоделировать продажи, используя расходы на рекламу и дополнительные _управляющие переменные_, такие как день недели, месяц, цена продукта, погода и т. д.

#### Модель

Построение сложных моделей, таких как XGBoost или глубокие нейронные сети, трудно интерпретировать и оптимизировать. Мы обращаемся к проверенному методу, который использует интерпретируемые эффекты переноса и насыщения для построения обобщённой аддитивной модели.

Блоки переноса и насыщения — это интуитивно понятные преобразования признаков:

* **Перенос** моделирует, что расходы на медиа в момент времени _t_ могут всё ещё влиять на продажи в моменты времени _t_ + 1, _t_ + 2 и т. д., или, наоборот, продажи, наблюдаемые в момент времени _t_, также зависят от расходов в моменты времени _t –_ 1, _t –_ 2 и т. д.
* **Насыщение** моделирует убывающие темпы возврата, например, увеличение ваших расходов по каналу с 0 € до 100 000 € имеет большое влияние, но изменение его с 1 000 000 000 до 1 000 100 000 больше не влияет.

> **Примечание:** на графике управляющие переменные опущены. Это нормально, потому что они нам всё равно не нужны для оптимизации — мы не можем их изменить, как деньги, которые мы вкладываем в наши медиаканалы. Единственная управляющая переменная, которую мы **можем** изменить, — это цена, но мы предполагаем, что она здесь постоянна, и что мы действительно хотим оптимизировать только наши расходы на медиа.

Модель имеет вид:

_β_ — коэффициент насыщения, _λ_ — сила переноса, _ℓ_ — длина переноса.

Мы можем узнать эти параметры, рассматривая их как гиперпараметры, или используя байесовские методы и рассматривая их как обычные обучаемые параметры. Мы видели в деталях, как получить эти параметры во всех моих последних статьях о моделировании комплекса маркетинга, поэтому я не буду вдаваться в эту тему.

Вместо этого давайте предположим, что у нас есть числа сейчас, и мы хотим использовать их для создания оптимизированного плана распределения медиабюджета.

#### Оптимизация медиабюджета

Давайте предположим, что наши предыдущие попытки моделирования комплекса маркетинга оставили нам следующие параметры:

```python
N = 200 

tv_coef = 10000       
tv_lags = 4           
tv_carryover = 0.5    
tv_saturation = 0.002 

radio_coef = 8000
radio_lags = 2
radio_carryover = 0.2
radio_saturation = 0.0001

banners_coef = 14000
banners_lags = 0
banners_carryover = 0.2
banners_saturation = 0.001
```

Мы теперь перестроим модель комплекса маркетинга в Python, используя numpy.

### Переимплементация нашей модели в Numpy

Сначала давайте определим некоторые матрицы, которые учитывают эффект переноса.

```python
import numpy as np

tv_carryover_matrix = sum([np.diag(tv_carryover**i*np.ones(N-i), k=-i) for i in range(tv_lags)])
radio_carryover_matrix = sum([np.diag(radio_carryover**i*np.ones(N-i), k=-i) for i in range(radio_lags)])
banners_carryover_matrix = np.eye(N)
```

Это реализует перенос с силой 0,2 и длиной 1. Вы можете увидеть это, если умножите эту матрицу на вектор расходов.

С этим покончено, давайте продолжим с насыщением. Это простая формула, включающая `exp`, так что проблем нет.

Мы можем написать:

```python
sales = (
    tv_coef * np.sum(1 - np.exp(-tv_saturation * tv_carryover_matrix @ data["TV"])) 
    + radio_coef * np.sum(1 - np.exp(-radio_saturation * radio_carryover_matrix @ data["Radio"])) 
    + banners_coef * np.sum(1 - np.exp(-banners_saturation * banners_carryover_matrix @ data["Banners"]))
)
```

Это даёт нам сумму продаж, **которые поступают от наших маркетинговых усилий**, поскольку мы игнорируем управляющие переменные здесь. Число составляет 3 584 648,73 €, и мы хотим увеличить его сейчас, изменив наши расходы на медиа!

### О результате

Вы также можете увидеть здесь интересный шаблон.

> Похоже, что тратить бюджет поровну — это лучший вариант.

Только расходы в первый период немного выше, но затем они как бы уравновешиваются. Это связано с тем, как работает наша модель: в первый период ещё нет адстока, поэтому нам нужно вложить немного больше, чтобы продажи начали расти. Начиная со второго периода, нам нужно вкладывать столько средств в модель, чтобы поддерживать высокий уровень адстока, но не слишком высокий из-за насыщения. В последний период адсток не имеет значения, поскольку время там заканчивается, как это предусмотрено моделью. Поэтому оптимизированный бюджет там ниже.

### Переимплементация нашей модели в CVXPY

Хорошо, теперь мы готовы получить оптимальное решение, используя cvxpy. Сначала мы определяем переменные, в нашем случае по одной для каждого канала и каждого временного шага, так что 3 __N_ = 3_200 = 600 переменных в сумме.

Без чего-либо ещё оптимум был бы установлен для всех переменных равным бесконечности, поэтому нам нужны некоторые ограничения. Переменные должны быть:

1. неотрицательными, и
2. мы хотим, чтобы сумма всех этих 600 переменных была меньше или равна тому, что мы потратили исторически.

Затем мы хотим оптимизировать модель, которую мы реализовали с помощью функций numpy, но используя их эквивалент в cvxpy вместо этого, что обычно означает написание `cp` вместо `np`. Мы даже можем повторно использовать матрицу переноса из предыдущего!

```python
import cvxpy as cp

original_total_spends = data[["TV", "Radio", "Banners"]].sum().sum()

tv = cp.Variable(N)
radio = cp.Variable(N)
banners = cp.Variable(N)

constraints = [
    tv >= 0,
    radio >= 0,
    banners >= 0,
    cp.sum(tv + radio + banners) <= original_total_spends,
]

problem = cp.Problem(
    cp.Maximize(
        tv_coef * cp.sum(1 - cp.exp(-tv_saturation * tv_carryover_matrix @ tv)) 
        + radio_coef * cp.sum(1 - cp.exp(-radio_saturation * radio_carryover_matrix @ radio)) 
        + banners_coef * cp.sum(1 - cp.exp(-banners_saturation * banners_carryover_matrix @ banners))
    ), 
    constraints
)
```

Мы можем теперь решить эту задачу максимизации за **очень короткое время** через

```python
problem.solve()
```

Мы можем получить оптимальный бюджет через `tv.value, radio.value, banners.value`. Вы можете увидеть, что расходы постоянны для каждой недели в каждом канале, что, возможно, не так интересно, как ожидалось. Но оптимально — это оптимально, так что мы возьмём это.

### Дополнительные ограничения

Вот и всё, теперь у вас есть базовый инструмент для оптимизации бюджета! И самое приятное то, что вы можете смоделировать ещё больше ограничений, которые могут возникнуть в бизнесе. Например, бизнес может сказать, что общие расходы на радио довольно высоки:

```python
sum(radio.value)
```

Бизнес хочет, чтобы это было меньше 300 000 € по стратегическим причинам, которые модель не может знать. Ладно, нет проблем, давайте добавим это в набор ограничений!

```python
constraints = [
    tv >= 0,
    radio >= 0,
    banners >= 0,
    cp.sum(tv + radio + banners) <= original_total_spends,
    cp.sum(radio) <= 300000 
]
```

Легко, как это. Мы можем снова запустить оптимизацию, и мы получим слегка сниженные оптимизированные продажи в размере 4 990 178,80 €. Но если мы проверим сумму расходов на радио сейчас

```python
sum(radio.value)
```

мы увидим, что бизнес-ограничение было соблюдено. И мы можем добавить ещё больше ограничений, таких как:

* сумма двух каналов должна быть меньше или больше некоторого числа, или
* в некоторые недели мы не допускаем никаких расходов на медиа.

Вам нужно только смоделировать это, используя некоторые суммы и равенства или неравенства.

#### Заключение

В этой статье мы сначала повторили формулы для моделей комплекса маркетинга. Это было важно, потому что нам нужно было перестроить модели. К счастью, поскольку наши модели просты и интерпретируемы, это было совсем несложно.

Наша модель имела ещё одно замечательное свойство: она вогнутая! В этом случае максимальное значение продаж однозначно определено, и мы могли добраться до него с помощью выпуклой оптимизации. Оптимизация невыпуклых или не вогнутых функций сложна в общем случае и больше похожа на искусство, связанное с настройкой многих гиперпараметров, поэтому мы не пошли по этому пути.

В качестве грандиозного финала мы оптимизировали наш медиабюджет! Пора было это сделать. Мы даже увидели, как включить больше ограничений в модель, например, что некоторые каналы нуждаются в минимальных или максимальных бюджетных ассигнованиях. Используя этот подход, вы теперь можете оптимизировать своё будущее распределение медиабюджета.

Другая оптимизация, о которой мы не говорили, — это **минимизация ваших медиабюджета** при условии, что вы хотите достичь определённой минимальной суммы продаж, то есть тратить как можно меньше денег, чтобы всё равно достичь своей цели. Это то, что вы также можете легко реализовать сами! В отличие от этого, прежде чем мы взяли все деньги, которые у нас были, и сделали как можно больше продаж.

