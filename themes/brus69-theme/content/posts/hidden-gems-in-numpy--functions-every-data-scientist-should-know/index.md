---
title: "Скрытые преимущества NumPy: 7 функций, которые должен знать каждый специалист по обработке данных | На пути к науке о данных"
date: "2025-11-19T23:13:09+0000"
draft: false
description: ""
h1: "Скрытые преимущества NumPy: 7 функций, которые должен знать каждый специалист по обработке данных"
urldel: "https://towardsdatascience.com/hidden-gems-in-numpy-7-functions-every-data-scientist-should-know/"
---

### Анализ данных с помощью NumPy

Уже год работаю с анализом данных. На данный момент я могу считать себя уверенным в SQL и Power BI. Переход на Python был довольно увлекательным. Я познакомился с некоторыми интересными и более умными подходами к анализу данных.

После того как я освежил свои навыки в основах Python, следующим идеальным шагом было начать изучать некоторые библиотеки Python для анализа данных. NumPy — одна из них. Как любитель математики, естественно, мне нравится исследовать эту библиотеку Python.

Эта библиотека предназначена для людей, которые хотят выполнять математические вычисления с помощью Python, от базовой математики и алгебры до продвинутых понятий, таких как исчисление. NumPy может практически всё это делать.

В этой статье я хотел познакомить вас с некоторыми функциями NumPy, с которыми я экспериментировал. Независимо от того, являетесь ли вы специалистом по анализу данных, финансовым аналитиком или любителем исследований, эти функции вам очень помогут.

## Пример набора данных (используется повсюду)

Перед тем как погрузиться, я определю небольшой набор данных, который будет использоваться во всех примерах:

```python
import numpy as np
temps = np.array([30, 32, 29, 35, 36, 33, 31])
```

Используя этот небольшой набор данных о температуре, я поделюсь 7 функциями, которые упрощают работу с массивами.

### 1. `np.where()` — векторизованный if-else

**Прежде чем я определю, что это за функция, вот краткое её представление:**

```python
arr = np.array([10, 15, 20, 25, 30])
indices = np.where(arr > 20)
print(indices)
```

**Вывод: (array([3, 4]),)**

`np.where` — это функция на основе условий. Когда задано условие, она выводит индекс/индексы, где это условие истинно. Например, в примере выше задан массив, и я объявил функцию `np.where`, которая извлекает записи, где элемент массива больше 20. Вывод — array([3, 4]), потому что это местоположение/индексы, где условие истинно — это будут 25 и 30.

### Условный выбор/замена

Это также полезно, когда вы пытаетесь определить пользовательский вывод для выходов, которые соответствуют вашему условию. Это часто используется в анализе данных. Например:

```python
import numpy as np
arr = np.array([1, 2, 3, 4, 5])
result = np.where(arr % 2 == 0, ‘even’, ‘odd’)
print(result)
```

**Вывод: [‘odd’ ‘even’ ‘odd’ ‘even’ ‘odd’]**

В примере выше пытаются извлечь чётные числа. После извлечения вызывается функция условного выбора/замены, которая добавляет пользовательское имя для наших условий. Если условие истинно, оно заменяется на even, а если условие ложно — на odd.

### Проблема: заменить все температуры выше 35 °C на 35 (ограничить экстремальные значения).

В реальных данных, особенно от датчиков, погодных станций или пользовательских вводов, выбросы довольно распространены — внезапные всплески или нереалистичные значения, которые не являются реалистичными.

```python
adjusted = np.where(temps > 35, 35, temps)
```

**Вывод: array([30, 32, 29, 35, 35, 33, 31])**

Теперь выглядит намного лучше. С помощью нескольких строк кода мы смогли исправить нереалистичные выбросы в нашем наборе данных.

### 2. `np.clip()` — сохранение значений в диапазоне

Во многих практических наборах данных значения могут выходить за пределы ожидаемого диапазона, вероятно, из-за шума измерений, ошибки пользователя или несоответствия масштабирования.

Например:

* Датчик температуры может показывать −10 °C, когда минимально возможное значение — 0 °C.
* Модель может прогнозировать вероятности, такие как 1,03 или −0,05 из-за округления.
* При нормализации значений пикселей для изображения некоторые из них могут выходить за пределы 0–255.

Эти «вне диапазона» значения могут:

* Нарушать последующие вычисления (например, логарифмические или процентные вычисления).
* Вызывать нереалистичные графики или артефакты (особенно при обработке сигналов/изображений).
* Искажать нормализацию и делать метрики ненадёжными.

`np.clip()` изящно решает эту проблему, ограничивая все элементы массива указанным минимальным и максимальным диапазоном.

**Проблема: обеспечить, чтобы все показания оставались в диапазоне [28, 35].**

```python
clipped = np.clip(temps, 28, 35)
clipped
```

**Вывод: array([30, 32, 29, 35, 35, 33, 31])**

Здесь происходит следующее:

* Любое значение ниже 28 становится 28.
* Любое значение выше 35 становится 35.
* Всё остальное остаётся прежним.

### 3. `np.ptp()` — найдите диапазон ваших данных за один раз

`np.ptp()` (peak-to-peak) показывает разницу между максимальным и минимальным элементами.

**Пример:**

```python
arr = np.array([[1, 5, 2],
[8, 3, 7]])
range_all = np.ptp(arr)
print(f”Peak-to-peak range of the entire array: {range_all}”)
```

**Вывод: Peak-to-peak range of the entire array: 7**

Понимание того, насколько варьируются ваши данные, часто так же важно, как и среднее значение. В метеорологических данных, например, это показывает, насколько стабильными или изменчивыми были условия.

### 4. `np.diff()` — обнаружение ежедневных изменений

`np.diff()` — это самый быстрый способ измерить импульс, рост или спад во времени. Он вычисляет различия между элементами в массиве.

**Пример:**

```python
temps = np.array([30, 32, 29, 35, 36, 33, 31])
daily_change = np.diff(temps)
print(daily_change)
```

**Вывод: [ 2 -3 6 1 -3 -2]**

### 5. `np.gradient()` — захват плавных тенденций и наклонов

`np.gradient()` вычисляет числовой градиент (сглаженную оценку изменения или наклона) по вашим данным. Он похож на `np.diff()`, однако `np.gradient()` работает, даже если ваши x-значения расположены неравномерно (например, нерегулярные временные метки).

**Пример:**

```python
time = np.array([0, 1, 2, 4, 7])
temp = np.array([30, 32, 34, 35, 36])
np.gradient(temp, time)
```

**Вывод: array([2. , 2. , 1.5 , 0.43333333, 0.33333333])**

### 6. `np.percentile()` — обнаружение выбросов или порогов

`np.percentile()` помогает вам извлекать фрагменты или срезы ваших данных. NumPy определяет это следующим образом: numpy.percentile **вычисляет q-й процентиль данных вдоль указанной оси**, где q — это процентное значение от 0 до 100.

**Пример:**

```python
import numpy as np
sales = np.array([45, 50, 52, 48, 60, 62, 58, 70, 72, 66, 63, 80])
np.percentile(sales, [25, 50, 75, 90])
```

**Вывод: [51.0 61.0 67.5 73.0]**

### 7. `np.unique()` — быстрый поиск уникальных значений и их количества

Эта функция идеально подходит для очистки, суммирования или категоризации данных. `np.unique()` находит все уникальные элементы в вашем массиве.

**Пример:**

```python
import numpy as np
products = np.array([
‘Shoes’, ‘Bags’, ‘Bags’, ‘Hats’,
‘Shoes’, ‘Shoes’, ‘Belts’, ‘Hats’
])
np.unique(products)
```

**Вывод: array([‘Bags’, ‘Belts’, ‘Hats’, ‘Shoes’], dtype=’ <U5′)**

Вы можете сделать ещё один шаг, посчитав количество раз, когда они появляются, используя свойство return_counts:

```python
np.unique(products, return_counts=True)
```

**Вывод: (array([‘Bags’, ‘Belts’, ‘Hats’, ‘Shoes’], dtype=’ <U5′), array([2, 1, 2, 3])**

### Подводя итог

Пока что это те функции, с которыми я столкнулся. И я считаю их довольно полезными в анализе данных. Прелесть NumPy в том, что чем больше вы с ним играете, тем больше вы обнаруживаете эти крошечные однострочники, которые заменяют страницы кода. Так что в следующий раз, когда вы будете работать с данными или отлаживать грязный набор данных, на некоторое время откажитесь от Pandas и попробуйте использовать одну из этих функций. Спасибо за чтение!

